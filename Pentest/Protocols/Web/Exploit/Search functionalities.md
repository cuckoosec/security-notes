## File Inclusion/Path Traversal
## NoSQL Injection
First, by reading MongoDB documentation you can find that the SQL `or 1=1` translates to `|| 1==1` (note the double =).

Then by poking around, you can see that a NULL BYTE will prevent MongoDB from using the rest of the query.

In some cases, you can also use the comments `//` or `<!--` to comment out the end of the query.

`https://ptl-2569e391-c157f1e8.libcurl.so/?username=admin%27%20||%201==1%20%00&password=bar&submit=Submit`
## LDAP Injection
When you are retrieving a user, based on its username, the following will be used:

```
(cn=[INPUT])
```

If you want to add more conditions and some boolean logic, you can use:

-   A boolean OR using |: (|(cn=[INPUT1])(cn=[INPUT2])) to get records matching [INPUT1] or [INPUT2].
-   A boolean AND using &: (&(cn=[INPUT1])(userPassword=[INPUT2])) to get records for which the cn matches [INPUT1] and the password matches [INPUT2].

As with other injections, we will need to remove anything added by the server-side code. We can get rid of the end of the filter, using a NULL BYTE (encoded as %00).

Here, we have a login script. We can see that if we use:

-   username=hacker&password=hacker we get authenticated (this is the normal request).
-   username=hack*&password=hacker we get authenticated (the wildcard matches the same value).
-   username=hacker&password=hac* we don't get authenticated (the password may likely be hashed).

Now we will see how we can use the LDAP injection via the username parameter, to bypass the authentication.

Based on our previous tests, we can deduce that the filter probably looks like:

```scss
(&(cn=[INPUT1])(userPassword=HASH[INPUT2]))
```

Where HASH is an unsalted hash (probably MD5 or SHA1).

Our goal here will be to inject inside [INPUT1] (the username parameter). We will need to inject:

-   The end of the current filter using hacker).
-   An always-true condition ((cn=*) for example)
-   A ) to keep a valid syntax and close the first (.
-   A NULL BYTE (%00) to get rid of the end of the filter.

In most cases, LDAP injection will allow only you to bypass authentication and authorization checks.

ReDoS
## SQL Injection
This example was first published in 2006 on [Chris Shiflett's Blog](http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string) as a way to bypass addslashes. It relies on the way MySQL will perform escaping. It will depend on the charset used by the connection. If the database driver is not aware of the charset used it will not perform the right escaping and create an exploitable situation. This exploit relies on the usage of [GBK](http://en.wikipedia.org/wiki/GBK). GBK is a character set for simplified Chinese. Using the fact that the database driver and the database don't "talk" the same charset, it's possible to generate a single quote and break out of the SQL syntax to inject a payload.

Using the string \xBF' (URL-encoded as %bf%27), it's possible to get a single quote that will not get escaped properly. It's therefore possible to inject an always-true condition using %bf%27 or 1=1 -- and bypass the authentication.

As a side note, this issue can be remediated by setting up the connection encoding to 'GBK' instead of using an SQL query (which is the source of this issue). Here the problem comes from the execution of the following query:

```sql
 SET CHARACTER SET 'GBK';
```

It is a pretty unlikely issue for a web application but it's always good to know that it exists, especially if you play CTFs.
## XPATH Injection
Just like SQL injection, XPath allows you to do boolean logic, and you can try:

-   `' and '1'='1` and you should get the same result.
-   `' or '1'='0` and you should get the same result.
-   `' and '1'='0` and you should not get any result.
-   `' or '1'='1` and you should get all results.

Based on these tests and previous knowledge of XPath, it's possible to get an idea of what the XPath expression looks like:

[PARENT NODES]/name[.='[INPUT]']/[CHILD NODES]

To comment out the rest of the XPath expression, you can use a NULL BYTE (which you will need to encode as %00). As we can see in the XPath expression above, we also need to add a `]` to properly complete the syntax. Our payload now looks like `hacker']%00` (or `hacker' or 1=1]%00` if we want all results).

If we try to find the child of the current node, using the payload `'%20or%201=1]/child::node()%00`, we don't get much information.

Here, the problem is that we need to get back up in the node hierarchy, to get more information. In XPath, this can be done using `parent::*` as part of the payload. We can now select the parent of the current node, and display all the child node using `hacker'%20or%201=1]/parent::*/child::node()%00`.